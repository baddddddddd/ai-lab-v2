#!/usr/bin/env python3
"""
!!! Code generated by Claude Sonnet 4 !!!

Farseer Scaling Law - Terminal Interface
Based on "Farseer: A Refined Scaling Law in Large Language Models"

Usage:
  python farseer.py predict --model-size 7B --dataset-size 14T
  python farseer.py optimize --compute-budget 1e24
  python farseer.py compare --compute-budget 1e24
  python farseer.py batch --file predictions.txt
"""

import numpy as np
import argparse
import sys
import json
from pathlib import Path


class FarseerScalingLaw:
    """
    Implementation of Farseer: A Refined Scaling Law for Large Language Models
    Formula: L(N, D) = e^(a3*N^Œ≥ + b3) + e^(a2*N^Œ≤ + b2) * D^(-e^(a1*N^Œ± + b1))
    """

    def __init__(self):
        # Fitted parameters from the paper (Equation 15)
        self.a1 = -0.124
        self.b1 = 0.424
        self.alpha = 0.123

        self.a2 = 88.01
        self.b2 = -6.287
        self.beta = -0.1

        self.a3 = -0.021
        self.b3 = -0.091
        self.gamma = 0.169

    def predict_loss(self, N, D):
        """Predict loss (BPC) for given model size N and dataset size D"""
        N = max(N, 1e6)
        D = max(D, 1e6)

        term1 = np.exp(self.a3 * (N**self.gamma) + self.b3)
        term2_coeff = np.exp(self.a2 * (N**self.beta) + self.b2)
        term2_exp = np.exp(self.a1 * (N**self.alpha) + self.b1)
        term2 = term2_coeff * (D ** (-term2_exp))

        return term1 + term2

    def find_optimal_allocation(self, compute_budget):
        """Find optimal N and D for given compute budget"""
        from scipy.optimize import minimize_scalar

        nd_budget = compute_budget / 6

        def objective(log_n):
            N = np.exp(log_n)
            D = nd_budget / N
            if D <= 0:
                return 1e10
            return self.predict_loss(N, D)

        result = minimize_scalar(
            objective, bounds=(np.log(1e6), np.log(nd_budget / 1e6)), method="bounded"
        )

        optimal_N = np.exp(result.x)
        optimal_D = nd_budget / optimal_N
        optimal_loss = result.fun

        return {
            "optimal_N": optimal_N,
            "optimal_D": optimal_D,
            "optimal_loss": optimal_loss,
            "D_over_N_ratio": optimal_D / optimal_N,
            "compute_budget": compute_budget,
        }

    def compare_with_chinchilla(self, compute_budget):
        """Compare Farseer vs Chinchilla allocation"""
        farseer_result = self.find_optimal_allocation(compute_budget)

        nd_budget = compute_budget / 6
        chinchilla_N = np.sqrt(nd_budget / 20)
        chinchilla_D = 20 * chinchilla_N
        chinchilla_loss = self.predict_loss(chinchilla_N, chinchilla_D)

        return {
            "farseer": farseer_result,
            "chinchilla": {
                "N": chinchilla_N,
                "D": chinchilla_D,
                "loss": chinchilla_loss,
                "D_over_N_ratio": 20.0,
            },
            "improvement": (chinchilla_loss - farseer_result["optimal_loss"])
            / chinchilla_loss
            * 100,
        }


def parse_size(size_str):
    """Parse size strings like '7B', '1.4T', '500M', '1e24'"""
    size_str = size_str.strip().upper()

    # Handle scientific notation
    if "E" in size_str:
        return float(size_str)

    # Handle standard suffixes
    multipliers = {"K": 1e3, "M": 1e6, "B": 1e9, "T": 1e12, "Q": 1e15}

    if size_str[-1] in multipliers:
        number = float(size_str[:-1])
        return number * multipliers[size_str[-1]]
    else:
        return float(size_str)


def format_size(value, unit=""):
    """Format large numbers with appropriate suffixes"""
    if value >= 1e15:
        return f"{value/1e15:.2f}Q{unit}"
    elif value >= 1e12:
        return f"{value/1e12:.2f}T{unit}"
    elif value >= 1e9:
        return f"{value/1e9:.2f}B{unit}"
    elif value >= 1e6:
        return f"{value/1e6:.2f}M{unit}"
    elif value >= 1e3:
        return f"{value/1e3:.2f}K{unit}"
    else:
        return f"{value:.2f}{unit}"


def cmd_predict(args):
    """Predict performance for given model and dataset size"""
    farseer = FarseerScalingLaw()

    N = parse_size(args.model_size)
    D = parse_size(args.dataset_size)
    loss = farseer.predict_loss(N, D)

    if args.json:
        result = {
            "model_size": N,
            "dataset_size": D,
            "predicted_loss": loss,
            "model_size_formatted": format_size(N),
            "dataset_size_formatted": format_size(D, " tokens"),
        }
        print(json.dumps(result, indent=2))
    else:
        print(f"üìä FARSEER PREDICTION")
        print(f"Model Size:    {format_size(N)} parameters")
        print(f"Dataset Size:  {format_size(D, ' tokens')}")
        print(f"Predicted Loss: {loss:.4f} BPC")

        if args.verbose:
            compute_used = 6 * N * D
            print(f"Compute Used:  {format_size(compute_used, ' FLOPs')}")
            print(f"D/N Ratio:     {D/N:.1f} tokens per parameter")


def cmd_optimize(args):
    """Find optimal resource allocation for compute budget"""
    farseer = FarseerScalingLaw()

    budget = parse_size(args.compute_budget)
    result = farseer.find_optimal_allocation(budget)

    if args.json:
        formatted_result = {
            "compute_budget": budget,
            "optimal_model_size": result["optimal_N"],
            "optimal_dataset_size": result["optimal_D"],
            "optimal_loss": result["optimal_loss"],
            "D_over_N_ratio": result["D_over_N_ratio"],
            "formatted": {
                "compute_budget": format_size(budget, " FLOPs"),
                "model_size": format_size(result["optimal_N"]),
                "dataset_size": format_size(result["optimal_D"], " tokens"),
            },
        }
        print(json.dumps(formatted_result, indent=2))
    else:
        print(f"‚ö° FARSEER OPTIMIZATION")
        print(f"Compute Budget: {format_size(budget, ' FLOPs')}")
        print(f"")
        print(f"üéØ OPTIMAL ALLOCATION:")
        print(f"Model Size:     {format_size(result['optimal_N'])} parameters")
        print(f"Dataset Size:   {format_size(result['optimal_D'], ' tokens')}")
        print(f"D/N Ratio:      {result['D_over_N_ratio']:.1f} tokens per parameter")
        print(f"Expected Loss:  {result['optimal_loss']:.4f} BPC")


def cmd_compare(args):
    """Compare Farseer vs Chinchilla allocation"""
    farseer = FarseerScalingLaw()

    budget = parse_size(args.compute_budget)
    comparison = farseer.compare_with_chinchilla(budget)

    if args.json:
        print(json.dumps(comparison, indent=2))
    else:
        print(f"‚öîÔ∏è  FARSEER vs CHINCHILLA")
        print(f"Compute Budget: {format_size(budget, ' FLOPs')}")
        print(f"")

        print(f"üî• FARSEER (OPTIMAL):")
        f_result = comparison["farseer"]
        print(f"  Model Size:   {format_size(f_result['optimal_N'])} parameters")
        print(f"  Dataset Size: {format_size(f_result['optimal_D'], ' tokens')}")
        print(f"  D/N Ratio:    {f_result['D_over_N_ratio']:.1f}")
        print(f"  Loss:         {f_result['optimal_loss']:.4f} BPC")
        print(f"")

        print(f"üìú CHINCHILLA RULE:")
        c_result = comparison["chinchilla"]
        print(f"  Model Size:   {format_size(c_result['N'])} parameters")
        print(f"  Dataset Size: {format_size(c_result['D'], ' tokens')}")
        print(f"  D/N Ratio:    {c_result['D_over_N_ratio']:.1f}")
        print(f"  Loss:         {c_result['loss']:.4f} BPC")
        print(f"")

        improvement = comparison["improvement"]
        print(f"üöÄ IMPROVEMENT: {improvement:.2f}% better with Farseer!")


def cmd_batch(args):
    """Process batch predictions from file"""
    farseer = FarseerScalingLaw()

    if not Path(args.file).exists():
        print(f"‚ùå Error: File {args.file} not found")
        sys.exit(1)

    results = []

    with open(args.file, "r") as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            try:
                parts = line.split()
                if len(parts) != 2:
                    print(f"‚ö†Ô∏è  Warning: Invalid format at line {line_num}: {line}")
                    continue

                N = parse_size(parts[0])
                D = parse_size(parts[1])
                loss = farseer.predict_loss(N, D)

                results.append(
                    {
                        "model_size": N,
                        "dataset_size": D,
                        "loss": loss,
                        "model_size_str": format_size(N),
                        "dataset_size_str": format_size(D, " tokens"),
                    }
                )

            except ValueError as e:
                print(f"‚ö†Ô∏è  Warning: Error parsing line {line_num}: {e}")
                continue

    if args.json:
        print(json.dumps(results, indent=2))
    else:
        print(f"üìã BATCH PREDICTIONS ({len(results)} models)")
        print(f"{'Model Size':<12} {'Dataset Size':<15} {'Loss (BPC)':<12}")
        print("-" * 45)
        for r in results:
            print(
                f"{r['model_size_str']:<12} {r['dataset_size_str']:<15} {r['loss']:<12.4f}"
            )


def main():
    parser = argparse.ArgumentParser(
        description="Farseer Scaling Law - Predict LLM performance and optimize resource allocation",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Predict performance
  python farseer.py predict --model-size 7B --dataset-size 14T
  python farseer.py predict -n 70B -d 1.4T --verbose
  
  # Find optimal allocation  
  python farseer.py optimize --compute-budget 1e24
  python farseer.py optimize -c 1e21 --json
  
  # Compare strategies
  python farseer.py compare --compute-budget 1e23
  
  # Batch processing (file format: model_size dataset_size per line)
  python farseer.py batch --file models.txt
        """,
    )

    parser.add_argument(
        "--json", action="store_true", help="Output results in JSON format"
    )
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Predict command
    predict_parser = subparsers.add_parser(
        "predict", help="Predict loss for given N and D"
    )
    predict_parser.add_argument(
        "--model-size", "-n", required=True, help="Model size (e.g., 7B, 1.4B, 70B)"
    )
    predict_parser.add_argument(
        "--dataset-size",
        "-d",
        required=True,
        help="Dataset size (e.g., 14T, 1.4T, 500B)",
    )

    # Optimize command
    optimize_parser = subparsers.add_parser(
        "optimize", help="Find optimal N and D for compute budget"
    )
    optimize_parser.add_argument(
        "--compute-budget",
        "-c",
        required=True,
        help="Compute budget in FLOPs (e.g., 1e24, 1e21)",
    )

    # Compare command
    compare_parser = subparsers.add_parser(
        "compare", help="Compare Farseer vs Chinchilla"
    )
    compare_parser.add_argument(
        "--compute-budget",
        "-c",
        required=True,
        help="Compute budget in FLOPs (e.g., 1e24, 1e21)",
    )

    # Batch command
    batch_parser = subparsers.add_parser(
        "batch", help="Process multiple predictions from file"
    )
    batch_parser.add_argument(
        "--file",
        "-f",
        required=True,
        help="Input file with model_size dataset_size per line",
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    try:
        if args.command == "predict":
            cmd_predict(args)
        elif args.command == "optimize":
            cmd_optimize(args)
        elif args.command == "compare":
            cmd_compare(args)
        elif args.command == "batch":
            cmd_batch(args)
    except Exception as e:
        print(f"‚ùå Error: {e}")
        if args.verbose:
            import traceback

            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
